{
  "address": "0xEF64C790Db07dEc6c0fe9197d4155db781990B6a",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "cidraw",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "size",
          "type": "uint256"
        }
      ],
      "name": "addCID",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "cidraw",
          "type": "bytes"
        },
        {
          "internalType": "uint64",
          "name": "provider",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "size",
          "type": "uint256"
        }
      ],
      "name": "authorizeData",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "method",
          "type": "uint64"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "flags",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "codec",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "params",
          "type": "bytes"
        },
        {
          "internalType": "uint64",
          "name": "id",
          "type": "uint64"
        }
      ],
      "name": "call_actor_id",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        },
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        },
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "name": "cidProviders",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "cidSet",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "cidSizes",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "deal_id",
          "type": "uint64"
        }
      ],
      "name": "claim_bounty",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "unused",
          "type": "uint64"
        }
      ],
      "name": "fund",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xfe677333d1e1dc844e26358ca84fb59238725ea69930c342b21827a15d863571",
  "receipt": {
    "to": null,
    "from": "0xb636C663De47df7cf95F1E87C86745dd7f7E3d67",
    "contractAddress": "0xEF64C790Db07dEc6c0fe9197d4155db781990B6a",
    "transactionIndex": 1,
    "gasUsed": "48162397",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001",
    "blockHash": "0x039c2288111ee81ae6caff223a18e01b428aefd6bbf056232a69005919303eb0",
    "transactionHash": "0xfe677333d1e1dc844e26358ca84fb59238725ea69930c342b21827a15d863571",
    "logs": [],
    "blockNumber": 29739,
    "cumulativeGasUsed": "0",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7ac4a71fbb40db4b598dddd96701a119",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"cidraw\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"addCID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"cidraw\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"provider\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"authorizeData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"method\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"flags\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"codec\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"id\",\"type\":\"uint64\"}],\"name\":\"call_actor_id\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"cidProviders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"cidSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"cidSizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"deal_id\",\"type\":\"uint64\"}],\"name\":\"claim_bounty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"unused\",\"type\":\"uint64\"}],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/filecoin-api-examples/DealRewarder.sol\":\"DealRewarder\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/filecoin-api-examples/DealRewarder.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport { MarketAPI } from \\\"../lib/filecoin-solidity/contracts/v0.8/MarketAPI.sol\\\";\\nimport { CommonTypes } from \\\"../lib/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol\\\";\\nimport { MarketTypes } from \\\"../lib/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol\\\";\\nimport { Actor, HyperActor } from \\\"../lib/filecoin-solidity/contracts/v0.8/utils/Actor.sol\\\";\\nimport { Misc } from \\\"../lib/filecoin-solidity/contracts/v0.8/utils/Misc.sol\\\";\\n\\n/* \\nContract Usage\\n    Step   |   Who   |    What is happening  |   Why \\n    ------------------------------------------------\\n    Deploy | contract owner   | contract owner deploys address is owner who can call addCID  | create contract setting up rules to follow\\n    AddCID | data pinners     | set up cids that the contract will incentivize in deals      | add request for a deal in the filecoin network, \\\"store data\\\" function\\n    Fund   | contract funders |  add FIL to the contract to later by paid out by deal        | ensure the deal actually gets stored by providing funds for bounty hunter and (indirect) storage provider\\n    Claim  | bounty hunter    | claim the incentive to complete the cycle                    | pay back the bounty hunter for doing work for the contract\\n\\n*/\\ncontract DealRewarder {\\n    mapping(bytes => bool) public cidSet;\\n    mapping(bytes => uint) public cidSizes;\\n    mapping(bytes => mapping(uint64 => bool)) public cidProviders;\\n\\n    address public owner;\\n    address constant CALL_ACTOR_ID = 0xfe00000000000000000000000000000000000005;\\n    uint64 constant DEFAULT_FLAG = 0x00000000;\\n    uint64 constant METHOD_SEND = 0;\\n    \\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    function fund(uint64 unused) public payable {}\\n\\n    function addCID(bytes calldata cidraw, uint size) public {\\n       require(msg.sender == owner);\\n       cidSet[cidraw] = true;\\n       cidSizes[cidraw] = size;\\n    }\\n\\n    function policyOK(bytes memory cidraw, uint64 provider) internal view returns (bool) {\\n        bool alreadyStoring = cidProviders[cidraw][provider];\\n        return !alreadyStoring;\\n    }\\n\\n    function authorizeData(bytes memory cidraw, uint64 provider, uint size) public {\\n        require(cidSet[cidraw], \\\"cid must be added before authorizing\\\");\\n        require(cidSizes[cidraw] == size, \\\"data size must match expected\\\");\\n        require(policyOK(cidraw, provider), \\\"deal failed policy check: has provider already claimed this cid?\\\");\\n\\n        cidProviders[cidraw][provider] = true;\\n    }\\n\\n    function claim_bounty(uint64 deal_id) public {\\n        MarketTypes.GetDealDataCommitmentReturn memory commitmentRet = MarketAPI.getDealDataCommitment(MarketTypes.GetDealDataCommitmentParams({id: deal_id}));\\n        MarketTypes.GetDealProviderReturn memory providerRet = MarketAPI.getDealProvider(MarketTypes.GetDealProviderParams({id: deal_id}));\\n\\n        authorizeData(commitmentRet.data, providerRet.provider, commitmentRet.size);\\n\\n        // get dealer (bounty hunter client)\\n        MarketTypes.GetDealClientReturn memory clientRet = MarketAPI.getDealClient(MarketTypes.GetDealClientParams({id: deal_id}));\\n\\n        // send reward to client \\n        send(clientRet.client);\\n    }\\n\\n    function call_actor_id(uint64 method, uint256 value, uint64 flags, uint64 codec, bytes memory params, uint64 id) public returns (bool, int256, uint64, bytes memory) {\\n        (bool success, bytes memory data) = address(CALL_ACTOR_ID).delegatecall(abi.encode(method, value, flags, codec, params, id));\\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(data, (int256, uint64, bytes));\\n        return (success, exit, return_codec, return_value);\\n    }\\n\\n    // send 1 FIL to the filecoin actor at actor_id\\n    function send(uint64 actorID) internal {\\n        bytes memory emptyParams = \\\"\\\";\\n        delete emptyParams;\\n\\n        uint oneFIL = 1000000000000000000;\\n        HyperActor.call_actor_id(METHOD_SEND, oneFIL, DEFAULT_FLAG, Misc.NONE_CODEC, emptyParams, actorID);\\n\\n    }\\n\\n}\\n\\n\",\"keccak256\":\"0xc66ac8b3d863c46f804260c61aa03aeed37e7bd9e566f39b11aab02e7986e633\",\"license\":\"UNLICENSED\"},\"contracts/lib/buffer/contracts/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for appending to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            let fpm := add(32, add(ptr, capacity))\\n            if lt(fpm, ptr) {\\n                revert(0, 0)\\n            }\\n            mstore(0x40, fpm)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        uint off = buf.buf.length;\\n        uint newCapacity = off + len;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(newCapacity, buflen) {\\n                mstore(bufptr, newCapacity)\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return append(buf, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint offPlusOne = off + 1;\\n        if (off >= buf.capacity) {\\n            resize(buf, offPlusOne * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if gt(offPlusOne, mload(bufptr)) {\\n                mstore(bufptr, offPlusOne)\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return append(buf, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return append(buf, data, 32);\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + newCapacity\\n            let dest := add(bufptr, newCapacity)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(newCapacity, mload(bufptr)) {\\n                mstore(bufptr, newCapacity)\\n            }\\n        }\\n        return buf;\\n    }\\n}\\n\",\"keccak256\":\"0xd6dd3b0b327288f8e1b711a609f4040fea602e2ad4bba9febdf2f33b4e56eb0c\",\"license\":\"BSD-2-Clause\"},\"contracts/lib/filecoin-solidity/contracts/v0.8/MarketAPI.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.4.25 <=0.8.17;\\n\\nimport \\\"./types/MarketTypes.sol\\\";\\nimport \\\"./cbor/MarketCbor.sol\\\";\\nimport \\\"./types/CommonTypes.sol\\\";\\nimport \\\"./utils/Misc.sol\\\";\\nimport \\\"./utils/Actor.sol\\\";\\n\\n\\nlibrary MarketAPI {\\n    using AddressCBOR for bytes;\\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceParams;\\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceReturn;\\n    using GetBalanceCBOR for MarketTypes.GetBalanceReturn;\\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentParams;\\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentReturn;\\n    using GetDealClientCBOR for MarketTypes.GetDealClientParams;\\n    using GetDealClientCBOR for MarketTypes.GetDealClientReturn;\\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderParams;\\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderReturn;\\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelParams;\\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelReturn;\\n    using GetDealTermCBOR for MarketTypes.GetDealTermParams;\\n    using GetDealTermCBOR for MarketTypes.GetDealTermReturn;\\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceParams;\\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceReturn;\\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralParams;\\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralReturn;\\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralParams;\\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralReturn;\\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedParams;\\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedReturn;\\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationParams;\\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationReturn;\\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsParams;\\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsReturn;\\n\\n    /// @return the data commitment and size of a deal proposal.\\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\\n    function getDealDataCommitment(\\n        MarketTypes.GetDealDataCommitmentParams memory params\\n    ) internal returns (MarketTypes.GetDealDataCommitmentReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory result = HyperActor.call(\\n            MarketTypes.GetDealDataCommitmentMethodNum,\\n            MarketTypes.ActorCode,\\n            raw_request,\\n            Misc.CBOR_CODEC\\n        );\\n\\n        MarketTypes.GetDealDataCommitmentReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the client of a deal proposal.\\n    function getDealClient(MarketTypes.GetDealClientParams memory params) internal returns (MarketTypes.GetDealClientReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory result = HyperActor.call(MarketTypes.GetDealClientMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        MarketTypes.GetDealClientReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the provider of a deal proposal.\\n    function getDealProvider(MarketTypes.GetDealProviderParams memory params) internal returns (MarketTypes.GetDealProviderReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory result = HyperActor.call(MarketTypes.GetDealProviderMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        MarketTypes.GetDealProviderReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n    \\n}\\n\\n/// @title This contract is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed.\\n/// @author Zondax AG\\nlibrary MarketAPIOld {\\n    using AddressCBOR for bytes;\\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceParams;\\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceReturn;\\n    using GetBalanceCBOR for MarketTypes.GetBalanceReturn;\\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentParams;\\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentReturn;\\n    using GetDealClientCBOR for MarketTypes.GetDealClientParams;\\n    using GetDealClientCBOR for MarketTypes.GetDealClientReturn;\\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderParams;\\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderReturn;\\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelParams;\\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelReturn;\\n    using GetDealTermCBOR for MarketTypes.GetDealTermParams;\\n    using GetDealTermCBOR for MarketTypes.GetDealTermReturn;\\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceParams;\\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceReturn;\\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralParams;\\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralReturn;\\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralParams;\\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralReturn;\\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedParams;\\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedReturn;\\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationParams;\\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationReturn;\\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsParams;\\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsReturn;\\n\\n    /// @notice Deposits the received value into the balance held in escrow.\\n    function addBalance(bytes memory provider_or_client) internal {\\n        bytes memory raw_request = provider_or_client.serializeAddress();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.AddBalanceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        Actor.readRespData(raw_response);\\n\\n        return;\\n    }\\n\\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\\n    /// @notice If less than the specified amount is available, yields the entire available balance.\\n    function withdrawBalance(MarketTypes.WithdrawBalanceParams memory params) internal returns (MarketTypes.WithdrawBalanceReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.WithdrawBalanceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.WithdrawBalanceReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the escrow balance and locked amount for an address.\\n    function getBalance(bytes memory addr) internal returns (MarketTypes.GetBalanceReturn memory) {\\n        bytes memory raw_request = addr.serializeAddress();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.GetBalanceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetBalanceReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the data commitment and size of a deal proposal.\\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\\n    function getDealDataCommitment(\\n        MarketTypes.GetDealDataCommitmentParams memory params\\n    ) internal returns (MarketTypes.GetDealDataCommitmentReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(\\n            MarketTypes.GetDealDataCommitmentMethodNum,\\n            MarketTypes.ActorCode,\\n            raw_request,\\n            Misc.CBOR_CODEC\\n        );\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealDataCommitmentReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the client of a deal proposal.\\n    function getDealClient(MarketTypes.GetDealClientParams memory params) internal returns (MarketTypes.GetDealClientReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealClientMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealClientReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the provider of a deal proposal.\\n    function getDealProvider(MarketTypes.GetDealProviderParams memory params) internal returns (MarketTypes.GetDealProviderReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealProviderMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealProviderReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the label of a deal proposal.\\n    function getDealLabel(MarketTypes.GetDealLabelParams memory params) internal returns (MarketTypes.GetDealLabelReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealLabelMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealLabelReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\\n    function getDealTerm(MarketTypes.GetDealTermParams memory params) internal returns (MarketTypes.GetDealTermReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealTermMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealTermReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the per-epoch price of a deal proposal.\\n    function getDealTotalPrice(\\n        MarketTypes.GetDealEpochPriceParams memory params\\n    ) internal returns (MarketTypes.GetDealEpochPriceReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealEpochPriceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealEpochPriceReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the client collateral requirement for a deal proposal.\\n    function getDealClientCollateral(\\n        MarketTypes.GetDealClientCollateralParams memory params\\n    ) internal returns (MarketTypes.GetDealClientCollateralReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(\\n            MarketTypes.GetDealClientCollateralMethodNum,\\n            MarketTypes.ActorCode,\\n            raw_request,\\n            Misc.CBOR_CODEC\\n        );\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealClientCollateralReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the provider collateral requirement for a deal proposal.\\n    function getDealProviderCollateral(\\n        MarketTypes.GetDealProviderCollateralParams memory params\\n    ) internal returns (MarketTypes.GetDealProviderCollateralReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(\\n            MarketTypes.GetDealProviderCollateralMethodNum,\\n            MarketTypes.ActorCode,\\n            raw_request,\\n            Misc.CBOR_CODEC\\n        );\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealProviderCollateralReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @return the verified flag for a deal proposal.\\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\\n    function getDealVerified(MarketTypes.GetDealVerifiedParams memory params) internal returns (MarketTypes.GetDealVerifiedReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealVerifiedMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealVerifiedReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @notice Fetches activation state for a deal.\\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\\n    function getDealActivation(\\n        MarketTypes.GetDealActivationParams memory params\\n    ) internal returns (MarketTypes.GetDealActivationReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealActivationMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.GetDealActivationReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n\\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\\n    function publishStorageDeals(\\n        MarketTypes.PublishStorageDealsParams memory params\\n    ) internal returns (MarketTypes.PublishStorageDealsReturn memory) {\\n        bytes memory raw_request = params.serialize();\\n\\n        bytes memory raw_response = Actor.call(\\n            MarketTypes.PublishStorageDealsMethodNum,\\n            MarketTypes.ActorCode,\\n            raw_request,\\n            Misc.CBOR_CODEC\\n        );\\n\\n        bytes memory result = Actor.readRespData(raw_response);\\n\\n        MarketTypes.PublishStorageDealsReturn memory response;\\n        response.deserialize(result);\\n\\n        return response;\\n    }\\n}\\n\",\"keccak256\":\"0x758f9e3742c2713fe56ce2a784e3c4ffb4653d9cf9ede7b860c35146b76dafc7\",\"license\":\"Apache-2.0\"},\"contracts/lib/filecoin-solidity/contracts/v0.8/cbor/BigIntCbor.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.4.25 <=0.8.17;\\n\\nstruct BigInt {\\n    bytes val;\\n    bool neg;\\n}\\n\\nlibrary BigIntCBOR {\\n    function serializeBigNum(BigInt memory num) internal pure returns (bytes memory) {\\n        // TODO improve gas efficiency by using assembly code\\n        bytes memory raw = new bytes(num.val.length + 1);\\n\\n        if (num.neg) {\\n            raw[0] = 0x01;\\n        }\\n\\n        uint index = 1;\\n        for (uint i = 0; i < num.val.length; i++) {\\n            raw[index] = num.val[i];\\n            index++;\\n        }\\n\\n        return raw;\\n    }\\n\\n    function deserializeBigNum(bytes memory raw) internal pure returns (BigInt memory) {\\n        // TODO improve gas efficiency by using assembly code\\n\\n        // Is an empty byte a valid BigInt ? We should have the sign byte at least\\n        if (raw.length == 0) {\\n            return BigInt(hex\\\"00\\\", false);\\n        }\\n\\n        bytes memory val = new bytes(raw.length - 1);\\n        bool neg = false;\\n\\n        if (raw[0] == 0x01) {\\n            neg = true;\\n        }\\n\\n        for (uint i = 1; i < raw.length; i++) {\\n            val[i - 1] = raw[i];\\n        }\\n\\n        return BigInt(val, neg);\\n    }\\n}\\n\",\"keccak256\":\"0xe0cf847dfe23dc41845b3e96e925e13a44206a95f89c48b522379ea368ce3703\",\"license\":\"Apache-2.0\"},\"contracts/lib/filecoin-solidity/contracts/v0.8/cbor/MarketCbor.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.4.25 <=0.8.17;\\n\\nimport \\\"../../../../solidity-cborutils/contracts/CBOR.sol\\\";\\n\\nimport {MarketTypes} from \\\"../types/MarketTypes.sol\\\";\\nimport \\\"./BigIntCbor.sol\\\";\\nimport \\\"../utils/CborDecode.sol\\\";\\nimport \\\"../utils/Misc.sol\\\";\\n\\n/// @title FIXME\\n/// @author Zondax AG\\nlibrary WithdrawBalanceCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n    using BigIntCBOR for BigInt;\\n    using BigIntCBOR for bytes;\\n\\n    function serialize(MarketTypes.WithdrawBalanceParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.startFixedArray(2);\\n        buf.writeBytes(params.provider_or_client);\\n        buf.writeBytes(params.tokenAmount.serializeBigNum());\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.WithdrawBalanceReturn memory ret, bytes memory rawResp) internal pure {\\n        bytes memory tmp;\\n        uint byteIdx = 0;\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.amount_withdrawn = tmp.deserializeBigNum();\\n    }\\n}\\n\\nlibrary AddressCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n\\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeBytes(addr);\\n\\n        return buf.data();\\n    }\\n\\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\\n        bytes memory addr;\\n        uint byteIdx = 0;\\n\\n        (addr, byteIdx) = ret.readBytes(byteIdx);\\n\\n        return addr;\\n    }\\n}\\n\\nlibrary GetBalanceCBOR {\\n    using CBORDecoder for bytes;\\n    using BigIntCBOR for bytes;\\n\\n    function deserialize(MarketTypes.GetBalanceReturn memory ret, bytes memory rawResp) internal pure {\\n        uint byteIdx = 0;\\n        uint len;\\n        bytes memory tmp;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 2);\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.balance = tmp.deserializeBigNum();\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.locked = tmp.deserializeBigNum();\\n    }\\n}\\n\\nlibrary GetDealDataCommitmentCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n\\n    function serialize(MarketTypes.GetDealDataCommitmentParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealDataCommitmentReturn memory ret, bytes memory rawResp) internal pure {\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n\\n        if (len > 0) {\\n            (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\\n            (ret.size, byteIdx) = rawResp.readUInt64(byteIdx);\\n        }\\n    }\\n}\\n\\nlibrary GetDealClientCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n\\n    function serialize(MarketTypes.GetDealClientParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealClientReturn memory ret, bytes memory rawResp) internal pure {\\n        uint byteIdx = 0;\\n\\n        (ret.client, byteIdx) = rawResp.readUInt64(byteIdx);\\n    }\\n}\\n\\nlibrary GetDealProviderCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n\\n    function serialize(MarketTypes.GetDealProviderParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealProviderReturn memory ret, bytes memory rawResp) internal pure {\\n        uint byteIdx = 0;\\n\\n        (ret.provider, byteIdx) = rawResp.readUInt64(byteIdx);\\n    }\\n}\\n\\nlibrary GetDealLabelCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n\\n    function serialize(MarketTypes.GetDealLabelParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealLabelReturn memory ret, bytes memory rawResp) internal pure {\\n        string memory label;\\n        uint byteIdx = 0;\\n\\n        (label, byteIdx) = rawResp.readString(byteIdx);\\n\\n        ret.label = label;\\n    }\\n}\\n\\nlibrary GetDealTermCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n\\n    function serialize(MarketTypes.GetDealTermParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealTermReturn memory ret, bytes memory rawResp) internal pure {\\n        int64 start;\\n        int64 end;\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 2);\\n\\n        (start, byteIdx) = rawResp.readInt64(byteIdx);\\n        (end, byteIdx) = rawResp.readInt64(byteIdx);\\n\\n        ret.start = start;\\n        ret.end = end;\\n    }\\n}\\n\\nlibrary GetDealEpochPriceCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n    using BigIntCBOR for bytes;\\n\\n    function serialize(MarketTypes.GetDealEpochPriceParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealEpochPriceReturn memory ret, bytes memory rawResp) internal pure {\\n        bytes memory tmp;\\n        uint byteIdx = 0;\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.price_per_epoch = tmp.deserializeBigNum();\\n    }\\n}\\n\\nlibrary GetDealClientCollateralCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n    using BigIntCBOR for bytes;\\n\\n    function serialize(MarketTypes.GetDealClientCollateralParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealClientCollateralReturn memory ret, bytes memory rawResp) internal pure {\\n        bytes memory tmp;\\n        uint byteIdx = 0;\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.collateral = tmp.deserializeBigNum();\\n    }\\n}\\n\\nlibrary GetDealProviderCollateralCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n    using BigIntCBOR for bytes;\\n\\n    function serialize(MarketTypes.GetDealProviderCollateralParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealProviderCollateralReturn memory ret, bytes memory rawResp) internal pure {\\n        bytes memory tmp;\\n        uint byteIdx = 0;\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.collateral = tmp.deserializeBigNum();\\n    }\\n}\\n\\nlibrary GetDealVerifiedCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n\\n    function serialize(MarketTypes.GetDealVerifiedParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealVerifiedReturn memory ret, bytes memory rawResp) internal pure {\\n        bool verified;\\n        uint byteIdx = 0;\\n\\n        (verified, byteIdx) = rawResp.readBool(byteIdx);\\n\\n        ret.verified = verified;\\n    }\\n}\\n\\nlibrary GetDealActivationCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n\\n    function serialize(MarketTypes.GetDealActivationParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.writeUInt64(params.id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.GetDealActivationReturn memory ret, bytes memory rawResp) internal pure {\\n        int64 activated;\\n        int64 terminated;\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 2);\\n\\n        (activated, byteIdx) = rawResp.readInt64(byteIdx);\\n        (terminated, byteIdx) = rawResp.readInt64(byteIdx);\\n\\n        ret.activated = activated;\\n        ret.terminated = terminated;\\n    }\\n}\\n\\nlibrary PublishStorageDealsCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n    using BigIntCBOR for BigInt;\\n\\n    function serialize(MarketTypes.PublishStorageDealsParams memory params) internal pure returns (bytes memory) {\\n        // FIXME what should the max length be on the buffer?\\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\\n\\n        buf.startFixedArray(1);\\n        buf.startFixedArray(uint64(params.deals.length));\\n\\n        for (uint64 i = 0; i < params.deals.length; i++) {\\n            buf.startFixedArray(11);\\n\\n            buf.writeBytes(params.deals[i].proposal.piece_cid);\\n            buf.writeUInt64(params.deals[i].proposal.piece_size);\\n            buf.writeBool(params.deals[i].proposal.verified_deal);\\n            buf.writeBytes(params.deals[i].proposal.client);\\n            buf.writeBytes(params.deals[i].proposal.provider);\\n            buf.writeString(params.deals[i].proposal.label);\\n            buf.writeInt64(params.deals[i].proposal.start_epoch);\\n            buf.writeInt64(params.deals[i].proposal.end_epoch);\\n            buf.writeBytes(params.deals[i].proposal.storage_price_per_epoch.serializeBigNum());\\n            buf.writeBytes(params.deals[i].proposal.provider_collateral.serializeBigNum());\\n            buf.writeBytes(params.deals[i].proposal.client_collateral.serializeBigNum());\\n\\n            buf.writeBytes(params.deals[i].client_signature);\\n        }\\n\\n        return buf.data();\\n    }\\n\\n    function deserialize(MarketTypes.PublishStorageDealsReturn memory ret, bytes memory rawResp) internal pure {\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        ret.ids = new uint64[](len);\\n\\n        for (uint i = 0; i < len; i++) {\\n            (ret.ids[i], byteIdx) = rawResp.readUInt64(byteIdx);\\n        }\\n\\n        (ret.valid_deals, byteIdx) = rawResp.readBytes(byteIdx);\\n    }\\n}\\n\",\"keccak256\":\"0xfad542627acb997285f5fde044485b4d0bf1dbe913c83668c27916c2ecbe182b\",\"license\":\"Apache-2.0\"},\"contracts/lib/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.4.25 <=0.8.17;\\n\\nimport \\\"../cbor/BigIntCbor.sol\\\";\\n\\n/// @title Filecoin actors' common types for Solidity.\\n/// @author Zondax AG\\nlibrary CommonTypes {\\n    enum RegisteredSealProof {\\n        StackedDRG2KiBV1,\\n        StackedDRG512MiBV1,\\n        StackedDRG8MiBV1,\\n        StackedDRG32GiBV1,\\n        StackedDRG64GiBV1,\\n        StackedDRG2KiBV1P1,\\n        StackedDRG512MiBV1P1,\\n        StackedDRG8MiBV1P1,\\n        StackedDRG32GiBV1P1,\\n        StackedDRG64GiBV1P1,\\n        Invalid\\n    }\\n\\n    enum RegisteredPoStProof {\\n        StackedDRGWinning2KiBV1,\\n        StackedDRGWinning8MiBV1,\\n        StackedDRGWinning512MiBV1,\\n        StackedDRGWinning32GiBV1,\\n        StackedDRGWinning64GiBV1,\\n        StackedDRGWindow2KiBV1,\\n        StackedDRGWindow8MiBV1,\\n        StackedDRGWindow512MiBV1,\\n        StackedDRGWindow32GiBV1,\\n        StackedDRGWindow64GiBV1,\\n        Invalid\\n    }\\n\\n    enum RegisteredUpdateProof {\\n        StackedDRG2KiBV1,\\n        StackedDRG8MiBV1,\\n        StackedDRG512MiBV1,\\n        StackedDRG32GiBV1,\\n        StackedDRG64GiBV1,\\n        Invalid\\n    }\\n    enum ExtensionKind {\\n        ExtendCommittmentLegacy,\\n        ExtendCommittment\\n    }\\n\\n    enum SectorSize {\\n        _2KiB,\\n        _8MiB,\\n        _512MiB,\\n        _32GiB,\\n        _64GiB\\n    }\\n\\n    struct ValidatedExpirationExtension {\\n        uint64 deadline;\\n        uint64 partition;\\n        uint8 sectors;\\n        int64 new_expiration;\\n    }\\n\\n    struct ExtendExpirationsInner {\\n        ValidatedExpirationExtension[] extensions;\\n        bytes claims; // FIXME this is a BTreeMap<SectorNumber, (u64, u64)> on rust\\n    }\\n\\n    struct PendingBeneficiaryChange {\\n        bytes new_beneficiary;\\n        BigInt new_quota;\\n        uint64 new_expiration;\\n        bool approved_by_beneficiary;\\n        bool approved_by_nominee;\\n    }\\n\\n    struct BeneficiaryTerm {\\n        BigInt quota;\\n        BigInt used_quota;\\n        uint64 expiration;\\n    }\\n\\n    struct ActiveBeneficiary {\\n        bytes beneficiary;\\n        BeneficiaryTerm term;\\n    }\\n\\n    struct RecoveryDeclaration {\\n        uint64 deadline;\\n        uint64 partition;\\n        uint8 sectors;\\n    }\\n\\n    struct FaultDeclaration {\\n        uint64 deadline;\\n        uint64 partition;\\n        uint8 sectors;\\n    }\\n\\n    struct TerminationDeclaration {\\n        uint64 deadline;\\n        uint64 partition;\\n        uint8 sectors;\\n    }\\n\\n    struct SectorClaim {\\n        uint64 sector_number;\\n        uint64[] maintain_claims;\\n        uint64[] drop_claims;\\n    }\\n\\n    struct ExpirationExtension2 {\\n        uint64 deadline;\\n        uint64 partition;\\n        uint8 sectors;\\n        SectorClaim[] sectors_with_claims;\\n        int64 new_expiration;\\n    }\\n\\n    struct ExpirationExtension {\\n        uint64 deadline;\\n        uint64 partition;\\n        uint8 sectors;\\n        int64 new_expiration;\\n    }\\n\\n    struct SectorPreCommitInfoInner {\\n        RegisteredSealProof seal_proof;\\n        uint64 sector_number;\\n        bytes sealed_cid;\\n        int64 seal_rand_epoch;\\n        uint64[] deal_ids;\\n        int64 expiration;\\n        bytes unsealed_cid;\\n    }\\n\\n    struct SectorPreCommitInfo {\\n        RegisteredSealProof seal_proof;\\n        uint64 sector_number;\\n        bytes sealed_cid;\\n        int64 seal_rand_epoch;\\n        uint64[] deal_ids;\\n        int64 expiration;\\n        bytes unsealed_cid;\\n    }\\n    struct ReplicaUpdateInner {\\n        uint64 sector_number;\\n        uint64 deadline;\\n        uint64 partition;\\n        bytes new_sealed_cid;\\n        bytes new_unsealed_cid;\\n        uint64[] deals;\\n        RegisteredUpdateProof update_proof_type;\\n        bytes replica_proof;\\n    }\\n\\n    struct ReplicaUpdate {\\n        uint64 sector_number;\\n        uint64 deadline;\\n        uint64 partition;\\n        bytes new_sealed_cid;\\n        uint64 deals;\\n        RegisteredUpdateProof update_proof_type;\\n        bytes replica_proof;\\n    }\\n\\n    struct ReplicaUpdate2 {\\n        uint64 sector_number;\\n        uint64 deadline;\\n        uint64 partition;\\n        bytes new_sealed_cid;\\n        bytes new_unsealed_cid;\\n        uint64 deals;\\n        RegisteredUpdateProof update_proof_type;\\n        bytes replica_proof;\\n    }\\n\\n    struct PoStPartition {\\n        uint64 index;\\n        int8 skipped;\\n    }\\n\\n    struct PoStProof {\\n        RegisteredPoStProof post_proof;\\n        bytes proof_bytes;\\n    }\\n\\n    struct VestingFunds {\\n        int64 epoch;\\n        BigInt amount;\\n    }\\n    struct SectorDeals {\\n        int64 sector_type;\\n        int64 sector_expiry;\\n        uint64[] deal_ids;\\n    }\\n\\n    struct DealProposal {\\n        bytes piece_cid;\\n        uint64 piece_size;\\n        bool verified_deal;\\n        bytes client;\\n        bytes provider;\\n        string label;\\n        int64 start_epoch;\\n        int64 end_epoch;\\n        BigInt storage_price_per_epoch;\\n        BigInt provider_collateral;\\n        BigInt client_collateral;\\n    }\\n\\n    struct ClientDealProposal {\\n        DealProposal proposal;\\n        bytes client_signature;\\n    }\\n\\n    struct SectorDealData {\\n        bytes commd;\\n    }\\n\\n    struct CID {\\n        uint8 version;\\n        uint64 codec;\\n        Multihash hash;\\n    }\\n\\n    struct Multihash {\\n        uint64 code;\\n        uint8 size;\\n        bytes digest;\\n    }\\n\\n    struct VerifiedDealInfo {\\n        uint64 client;\\n        uint64 allocation_id;\\n        bytes data;\\n        uint64 size;\\n    }\\n\\n    struct SectorDataSpec {\\n        uint64[] deal_ids;\\n        int64 sector_type;\\n    }\\n\\n    struct FailCode {\\n        uint32 idx;\\n        uint32 code;\\n    }\\n\\n    struct BatchReturn {\\n        // Total successes in batch\\n        uint32 success_count;\\n        // Failure code and index for each failure in batch\\n        FailCode[] fail_codes;\\n    }\\n\\n    struct Claim {\\n        // The provider storing the data (from allocation).\\n        uint64 provider;\\n        // The client which allocated the DataCap (from allocation).\\n        uint64 client;\\n        // Identifier of the data committed (from allocation).\\n        bytes data;\\n        // The (padded) size of data (from allocation).\\n        uint64 size;\\n        // The min period after term_start which the provider must commit to storing data\\n        int64 term_min;\\n        // The max period after term_start for which provider can earn QA-power for the data\\n        int64 term_max;\\n        // The epoch at which the (first range of the) piece was committed.\\n        int64 term_start;\\n        // ID of the provider's sector in which the data is committed.\\n        uint64 sector;\\n    }\\n    struct ClaimTerm {\\n        uint64 provider;\\n        uint64 claim_id;\\n        int64 term_max;\\n    }\\n}\\n\",\"keccak256\":\"0xa08db4b175de9872189dc1ce687c3c5ea5839f0d67515f904c0235eb2475e559\",\"license\":\"Apache-2.0\"},\"contracts/lib/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.4.25 <=0.8.17;\\n\\nimport \\\"../cbor/BigIntCbor.sol\\\";\\nimport \\\"./CommonTypes.sol\\\";\\n\\n/// @title Filecoin market actor types for Solidity.\\n/// @author Zondax AG\\nlibrary MarketTypes {\\n    bytes constant ActorCode = hex\\\"0005\\\";\\n    uint constant AddBalanceMethodNum = 822473126;\\n    uint constant WithdrawBalanceMethodNum = 2280458852;\\n    uint constant GetBalanceMethodNum = 726108461;\\n    uint constant GetDealDataCommitmentMethodNum = 1157985802;\\n    uint constant GetDealClientMethodNum = 128053329;\\n    uint constant GetDealProviderMethodNum = 935081690;\\n    uint constant GetDealLabelMethodNum = 46363526;\\n    uint constant GetDealTermMethodNum = 163777312;\\n    uint constant GetDealEpochPriceMethodNum = 4287162428;\\n    uint constant GetDealClientCollateralMethodNum = 200567895;\\n    uint constant GetDealProviderCollateralMethodNum = 2986712137;\\n    uint constant GetDealVerifiedMethodNum = 2627389465;\\n    uint constant GetDealActivationMethodNum = 2567238399;\\n    uint constant PublishStorageDealsMethodNum = 2236929350;\\n\\n    struct WithdrawBalanceParams {\\n        bytes provider_or_client;\\n        BigInt tokenAmount;\\n    }\\n\\n    struct WithdrawBalanceReturn {\\n        BigInt amount_withdrawn;\\n    }\\n\\n    struct GetBalanceReturn {\\n        BigInt balance;\\n        BigInt locked;\\n    }\\n\\n    struct GetDealDataCommitmentParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealDataCommitmentReturn {\\n        bytes data;\\n        uint64 size;\\n    }\\n\\n    struct GetDealClientParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealClientReturn {\\n        uint64 client;\\n    }\\n\\n    struct GetDealProviderParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealProviderReturn {\\n        uint64 provider;\\n    }\\n\\n    struct GetDealLabelParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealLabelReturn {\\n        string label;\\n    }\\n\\n    struct GetDealTermParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealTermReturn {\\n        int64 start;\\n        int64 end;\\n    }\\n\\n    struct GetDealEpochPriceParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealEpochPriceReturn {\\n        BigInt price_per_epoch;\\n    }\\n\\n    struct GetDealClientCollateralParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealClientCollateralReturn {\\n        BigInt collateral;\\n    }\\n\\n    struct GetDealProviderCollateralParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealProviderCollateralReturn {\\n        BigInt collateral;\\n    }\\n\\n    struct GetDealVerifiedParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealVerifiedReturn {\\n        bool verified;\\n    }\\n\\n    struct GetDealActivationParams {\\n        uint64 id;\\n    }\\n\\n    struct GetDealActivationReturn {\\n        int64 activated;\\n        int64 terminated;\\n    }\\n\\n    struct PublishStorageDealsParams {\\n        CommonTypes.ClientDealProposal[] deals;\\n    }\\n\\n    struct PublishStorageDealsReturn {\\n        uint64[] ids;\\n        bytes valid_deals;\\n    }\\n}\\n\",\"keccak256\":\"0x9815d57588adad96207294344954daecdccb46935607a156907a5a5e36220a19\",\"license\":\"Apache-2.0\"},\"contracts/lib/filecoin-solidity/contracts/v0.8/utils/Actor.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.4.25 <=0.8.17;\\n\\nimport \\\"../../../../openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\n\\nimport \\\"./Misc.sol\\\";\\n\\nlibrary HyperActor {\\n    address constant CALL_ACTOR_ADDRESS = 0xfe00000000000000000000000000000000000003;\\n    address constant CALL_ACTOR_ID = 0xfe00000000000000000000000000000000000005;\\n    uint64 constant DEFAULT_FLAG = 0x00000000;\\n\\n    function convert (uint256 _a) internal returns (uint64) \\n    {\\n        return uint64(_a);\\n    }\\n\\n    function call_actor_id(uint64 method, uint256 value, uint64 flags, uint64 codec, bytes memory params, uint64 id) internal returns (bool, int256, uint64, bytes memory) {\\n        (bool success, bytes memory data) = address(CALL_ACTOR_ID).delegatecall(abi.encode(method, value, flags, codec, params, id));\\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(data, (int256, uint64, bytes));\\n        return (success, exit, return_codec, return_value);\\n    }\\n\\n    function call_actor_address(uint64 method, uint256 value, uint64 flags, uint64 codec, bytes memory params, bytes memory filAddress) internal returns (bool, int256, uint64, bytes memory) {\\n        (bool success, bytes memory data) = address(CALL_ACTOR_ADDRESS).delegatecall(abi.encode(method, value, flags, codec, params, filAddress));\\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(data, (int256, uint64, bytes));\\n        return (success, exit, return_codec, return_value);\\n    }\\n\\n    function call(uint method, bytes memory filAddress, bytes memory params, uint64 codec) internal returns (bytes memory) {\\n        return call_inner(convert(method), filAddress, params, codec, msg.value);\\n    }\\n\\n    function call_inner(uint method, bytes memory filAddress, bytes memory params, uint64 codec, uint amount) internal returns (bytes memory ) {\\n        (bool _success, int256 exit_code, uint64 _return_codec, bytes memory return_value) = call_actor_address(convert(method), amount, DEFAULT_FLAG, codec, params, filAddress);\\n        require(exit_code == 0, string.concat(\\\"actor error code \\\", Strings.toString(exit_code)));\\n        return return_value;\\n    }\\n}\\n\\n\\n\\nlibrary Actor {\\n    uint64 constant GAS_LIMIT = 100000000;\\n    uint64 constant CALL_ACTOR_PRECOMPILE_ADDR = 0x0e;\\n    uint64 constant MAX_RAW_RESPONSE_SIZE = 0x300;\\n    uint64 constant READ_ONLY_FLAG = 0x00000001; // https://github.com/filecoin-project/ref-fvm/blob/master/shared/src/sys/mod.rs#L60\\n    uint64 constant DEFAULT_FLAG = 0x00000000;\\n\\n    function call(uint method_num, bytes memory actor_code, bytes memory raw_request, uint64 codec) internal returns (bytes memory) {\\n        call_inner(method_num, actor_code, raw_request, codec, msg.value);\\n    }\\n\\n    function call_inner(uint method_num, bytes memory actor_code, bytes memory raw_request, uint64 codec, uint amount) internal returns (bytes memory) {\\n        bytes memory raw_response = new bytes(MAX_RAW_RESPONSE_SIZE);\\n\\n        uint raw_request_len;\\n        uint actor_code_len;\\n\\n        assembly {\\n            raw_request_len := mload(raw_request)\\n            actor_code_len := mload(actor_code)\\n\\n            let input := mload(0x40)\\n            mstore(input, method_num)\\n            // value to send\\n            mstore(add(input, 0x20), amount)\\n            // readonly flag is mandatory for now\\n            mstore(add(input, 0x40), DEFAULT_FLAG)\\n            // cbor codec is mandatory for now\\n            mstore(add(input, 0x60), codec)\\n            // params size\\n            mstore(add(input, 0x80), raw_request_len)\\n            // address size\\n            mstore(add(input, 0xa0), actor_code_len)\\n            // actual params (copy by slice of 32 bytes)\\n            let start_index := 0xc0\\n            let offset := 0\\n            for {\\n                offset := 0x00\\n            } lt(offset, raw_request_len) {\\n                offset := add(offset, 0x20)\\n            } {\\n                mstore(add(input, add(start_index, offset)), mload(add(raw_request, add(0x20, offset))))\\n            }\\n            if mod(raw_request_len, 0x20) {\\n                offset := add(sub(offset, 0x20), mod(raw_request_len, 0x20))\\n            }\\n\\n            // actual address (copy by slice of 32 bytes)\\n            start_index := add(start_index, offset)\\n            offset := 0\\n            for {\\n                offset := 0x00\\n            } lt(offset, actor_code_len) {\\n                offset := add(offset, 0x20)\\n            } {\\n                mstore(add(input, add(start_index, offset)), mload(add(actor_code, add(0x20, offset))))\\n            }\\n            if mod(actor_code_len, 0x20) {\\n                offset := add(sub(offset, 0x20), mod(actor_code_len, 0x20))\\n            }\\n\\n            let len := add(start_index, offset)\\n\\n            // FIXME set inputSize according to the input length\\n            // delegatecall(gasLimit, to, inputOffset, inputSize, outputOffset, outputSize)\\n            if iszero(delegatecall(GAS_LIMIT, CALL_ACTOR_PRECOMPILE_ADDR, input, len, raw_response, MAX_RAW_RESPONSE_SIZE)) {\\n                revert(0, 0)\\n            }\\n        }\\n\\n        return raw_response;\\n    }\\n\\n    function readRespData(bytes memory raw_response) internal pure returns (bytes memory) {\\n        uint256 exit_code = Misc.toUint256(raw_response, 0x00);\\n        uint256 size = Misc.toUint256(raw_response, 0x60);\\n        require(exit_code == 0, string.concat(\\\"actor error code \\\", Strings.toString(exit_code)));\\n\\n        bytes memory result = new bytes(size);\\n        uint src;\\n        uint dst;\\n        assembly {\\n            src := add(raw_response, 0x80)\\n            dst := add(result, 0x20)\\n        }\\n        Misc.copy(src, dst, size);\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xd373081209278eae8e49694f9056dd6558cf1f66e4831805208b3efa93e2062e\",\"license\":\"Apache-2.0\"},\"contracts/lib/filecoin-solidity/contracts/v0.8/utils/CborDecode.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.4.25 <=0.8.17;\\n\\n// \\tMajUnsignedInt = 0\\n// \\tMajSignedInt   = 1\\n// \\tMajByteString  = 2\\n// \\tMajTextString  = 3\\n// \\tMajArray       = 4\\n// \\tMajMap         = 5\\n// \\tMajTag         = 6\\n// \\tMajOther       = 7\\n\\nuint8 constant MajUnsignedInt = 0;\\nuint8 constant MajSignedInt = 1;\\nuint8 constant MajByteString = 2;\\nuint8 constant MajTextString = 3;\\nuint8 constant MajArray = 4;\\nuint8 constant MajMap = 5;\\nuint8 constant MajTag = 6;\\nuint8 constant MajOther = 7;\\n\\nuint8 constant TagTypeBigNum = 2;\\nuint8 constant TagTypeNegativeBigNum = 3;\\n\\nuint8 constant True_Type = 21;\\nuint8 constant False_Type = 20;\\n\\nlibrary CBORDecoder {\\n    function isNullNext(bytes memory cborParams, uint byteIdx) internal pure returns (bool) {\\n        return cborParams[byteIdx] == hex\\\"f6\\\";\\n    }\\n\\n    function readBool(bytes memory cborParams, uint byteIdx) internal pure returns (bool, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajOther);\\n        assert(value == True_Type || value == False_Type);\\n\\n        return (value != False_Type, byteIdx);\\n    }\\n\\n    function readFixedArray(bytes memory cborParams, uint byteIdx) internal pure returns (uint, uint) {\\n        uint8 maj;\\n        uint len;\\n\\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajArray);\\n\\n        return (len, byteIdx);\\n    }\\n\\n    function readString(bytes memory cborParams, uint byteIdx) internal pure returns (string memory, uint) {\\n        uint8 maj;\\n        uint len;\\n\\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajTextString);\\n\\n        uint max_len = byteIdx + len;\\n        bytes memory slice = new bytes(len);\\n        uint slice_index = 0;\\n        for (uint256 i = byteIdx; i < max_len; i++) {\\n            slice[slice_index] = cborParams[i];\\n            slice_index++;\\n        }\\n\\n        return (string(slice), byteIdx + len);\\n    }\\n\\n    function readBytes(bytes memory cborParams, uint byteIdx) internal pure returns (bytes memory, uint) {\\n        uint8 maj;\\n        uint len;\\n\\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajTag || maj == MajByteString);\\n\\n        if (maj == MajTag) {\\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n            assert(maj == MajByteString);\\n        }\\n\\n        uint max_len = byteIdx + len;\\n        bytes memory slice = new bytes(len);\\n        uint slice_index = 0;\\n        for (uint256 i = byteIdx; i < max_len; i++) {\\n            slice[slice_index] = cborParams[i];\\n            slice_index++;\\n        }\\n\\n        return (slice, byteIdx + len);\\n    }\\n\\n    function readBytes32(bytes memory cborParams, uint byteIdx) internal pure returns (bytes32, uint) {\\n        uint8 maj;\\n        uint len;\\n\\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajByteString);\\n\\n        uint max_len = byteIdx + len;\\n        bytes memory slice = new bytes(32);\\n        uint slice_index = 32 - len;\\n        for (uint256 i = byteIdx; i < max_len; i++) {\\n            slice[slice_index] = cborParams[i];\\n            slice_index++;\\n        }\\n\\n        return (bytes32(slice), byteIdx + len);\\n    }\\n\\n    function readUInt256(bytes memory cborParams, uint byteIdx) internal pure returns (uint256, uint) {\\n        uint8 maj;\\n        uint256 value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajTag || maj == MajUnsignedInt);\\n\\n        if (maj == MajTag) {\\n            assert(value == TagTypeBigNum);\\n\\n            uint len;\\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n            assert(maj == MajByteString);\\n\\n            require(cborParams.length >= byteIdx + len, \\\"slicing out of range\\\");\\n            assembly {\\n                value := mload(add(cborParams, add(len, byteIdx)))\\n            }\\n\\n            return (value, byteIdx + len);\\n        }\\n\\n        return (value, byteIdx);\\n    }\\n\\n    function readInt256(bytes memory cborParams, uint byteIdx) internal pure returns (int256, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajTag || maj == MajSignedInt);\\n\\n        if (maj == MajTag) {\\n            assert(value == TagTypeNegativeBigNum);\\n\\n            uint len;\\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n            assert(maj == MajByteString);\\n\\n            require(cborParams.length >= byteIdx + len, \\\"slicing out of range\\\");\\n            assembly {\\n                value := mload(add(cborParams, add(len, byteIdx)))\\n            }\\n\\n            return (int256(value), byteIdx + len);\\n        }\\n\\n        return (int256(value), byteIdx);\\n    }\\n\\n    function readUInt64(bytes memory cborParams, uint byteIdx) internal pure returns (uint64, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajUnsignedInt);\\n\\n        return (uint64(value), byteIdx);\\n    }\\n\\n    function readUInt32(bytes memory cborParams, uint byteIdx) internal pure returns (uint32, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajUnsignedInt);\\n\\n        return (uint32(value), byteIdx);\\n    }\\n\\n    function readUInt16(bytes memory cborParams, uint byteIdx) internal pure returns (uint16, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajUnsignedInt);\\n\\n        return (uint16(value), byteIdx);\\n    }\\n\\n    function readUInt8(bytes memory cborParams, uint byteIdx) internal pure returns (uint8, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajUnsignedInt);\\n\\n        return (uint8(value), byteIdx);\\n    }\\n\\n    function readInt64(bytes memory cborParams, uint byteIdx) internal pure returns (int64, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\\n\\n        return (int64(uint64(value)), byteIdx);\\n    }\\n\\n    function readInt32(bytes memory cborParams, uint byteIdx) internal pure returns (int32, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\\n\\n        return (int32(uint32(value)), byteIdx);\\n    }\\n\\n    function readInt16(bytes memory cborParams, uint byteIdx) internal pure returns (int16, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\\n\\n        return (int16(uint16(value)), byteIdx);\\n    }\\n\\n    function readInt8(bytes memory cborParams, uint byteIdx) internal pure returns (int8, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\\n\\n        return (int8(uint8(value)), byteIdx);\\n    }\\n\\n    function sliceUInt8(bytes memory bs, uint start) internal pure returns (uint8) {\\n        require(bs.length >= start + 1, \\\"slicing out of range\\\");\\n        uint8 x;\\n        assembly {\\n            x := mload(add(bs, add(0x01, start)))\\n        }\\n        return x;\\n    }\\n\\n    function sliceUInt16(bytes memory bs, uint start) internal pure returns (uint16) {\\n        require(bs.length >= start + 2, \\\"slicing out of range\\\");\\n        uint16 x;\\n        assembly {\\n            x := mload(add(bs, add(0x02, start)))\\n        }\\n        return x;\\n    }\\n\\n    function sliceUInt32(bytes memory bs, uint start) internal pure returns (uint32) {\\n        require(bs.length >= start + 4, \\\"slicing out of range\\\");\\n        uint32 x;\\n        assembly {\\n            x := mload(add(bs, add(0x04, start)))\\n        }\\n        return x;\\n    }\\n\\n    function sliceUInt64(bytes memory bs, uint start) internal pure returns (uint64) {\\n        require(bs.length >= start + 8, \\\"slicing out of range\\\");\\n        uint64 x;\\n        assembly {\\n            x := mload(add(bs, add(0x08, start)))\\n        }\\n        return x;\\n    }\\n\\n    // Parse cbor header for major type and extra info.\\n    // Also return the byte index after moving past header bytes, and the number of bytes consumed\\n    function parseCborHeader(bytes memory cbor, uint byteIndex) internal pure returns (uint8, uint64, uint) {\\n        uint8 first = sliceUInt8(cbor, byteIndex);\\n        byteIndex += 1;\\n        uint8 maj = (first & 0xe0) >> 5;\\n        uint8 low = first & 0x1f;\\n        // We don't handle CBOR headers with extra > 27, i.e. no indefinite lengths\\n        assert(low < 28);\\n\\n        // extra is lower bits\\n        if (low < 24) {\\n            return (maj, low, byteIndex);\\n        }\\n\\n        // extra in next byte\\n        if (low == 24) {\\n            uint8 next = sliceUInt8(cbor, byteIndex);\\n            byteIndex += 1;\\n            assert(next >= 24); // otherwise this is invalid cbor\\n            return (maj, next, byteIndex);\\n        }\\n\\n        // extra in next 2 bytes\\n        if (low == 25) {\\n            uint16 extra16 = sliceUInt16(cbor, byteIndex);\\n            byteIndex += 2;\\n            return (maj, extra16, byteIndex);\\n        }\\n\\n        // extra in next 4 bytes\\n        if (low == 26) {\\n            uint32 extra32 = sliceUInt32(cbor, byteIndex);\\n            byteIndex += 4;\\n            return (maj, extra32, byteIndex);\\n        }\\n\\n        // extra in next 8 bytes\\n        assert(low == 27);\\n        uint64 extra64 = sliceUInt64(cbor, byteIndex);\\n        byteIndex += 8;\\n        return (maj, extra64, byteIndex);\\n    }\\n}\\n\",\"keccak256\":\"0x3502c9b3408b2391745c642ef547f930f42099cfab813a70af1dd39525aa3a43\",\"license\":\"Apache-2.0\"},\"contracts/lib/filecoin-solidity/contracts/v0.8/utils/Misc.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.4.25 <=0.8.17;\\n\\nlibrary Misc {\\n    uint64 constant CBOR_CODEC = 0x71;\\n    uint64 constant NONE_CODEC = 0x00;\\n\\n    function toUint256(bytes32 _bytes) internal pure returns (uint256 value) {\\n        return uint256(_bytes);\\n    }\\n\\n    function toInt256(bytes32 _bytes) internal pure returns (int256 value) {\\n        return int256(uint256(_bytes));\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint offset) internal pure returns (uint256 value) {\\n        assembly {\\n            value := mload(add(_bytes, offset))\\n        }\\n    }\\n\\n    function toInt256(bytes memory _bytes, uint offset) internal pure returns (int256 value) {\\n        return int256(toUint256(_bytes, offset));\\n    }\\n\\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly {\\n            mstore(add(b, 32), x)\\n        }\\n    }\\n\\n    function toBytes(int256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly {\\n            mstore(add(b, 32), x)\\n        }\\n    }\\n\\n    function copy(uint src, uint dest, uint len) internal pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        if (len == 0) return;\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2b7477d6d6f83047a2c2b988fa924d2826a8271137f80d2b77ebba6936fd45b4\",\"license\":\"Apache-2.0\"},\"contracts/lib/openzeppelin-contracts/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x2626d8ab3dfdad0fad630c212ad146d59473d0f48b771784c61a7c1dbbea1f3f\",\"license\":\"MIT\"},\"contracts/lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3546b156d97633f7f8cad536d5454c81d1d604687c02b2eb105fdc33cb962b41\",\"license\":\"MIT\"},\"contracts/lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/lib/solidity-cborutils/contracts/CBOR.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../../buffer/contracts/Buffer.sol\\\";\\n\\n/**\\n* @dev A library for populating CBOR encoded payload in Solidity.\\n*\\n* https://datatracker.ietf.org/doc/html/rfc7049\\n*\\n* The library offers various write* and start* methods to encode values of different types.\\n* The resulted buffer can be obtained with data() method.\\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\\n* in an invalid CBOR if start/write/end flow is violated.\\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\\n* except for nested start/end pairs.\\n*/\\n\\nlibrary CBOR {\\n    using Buffer for Buffer.buffer;\\n\\n    struct CBORBuffer {\\n        Buffer.buffer buf;\\n        uint256 depth;\\n    }\\n\\n    uint8 private constant MAJOR_TYPE_INT = 0;\\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\\n    uint8 private constant MAJOR_TYPE_STRING = 3;\\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n    uint8 private constant MAJOR_TYPE_MAP = 5;\\n    uint8 private constant MAJOR_TYPE_TAG = 6;\\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n    uint8 private constant CBOR_FALSE = 20;\\n    uint8 private constant CBOR_TRUE = 21;\\n    uint8 private constant CBOR_NULL = 22;\\n    uint8 private constant CBOR_UNDEFINED = 23;\\n\\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\\n        Buffer.init(cbor.buf, capacity);\\n        cbor.depth = 0;\\n        return cbor;\\n    }\\n\\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\\n        require(buf.depth == 0, \\\"Invalid CBOR\\\");\\n        return buf.buf.buf;\\n    }\\n\\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n        writeBytes(buf, abi.encode(value));\\n    }\\n\\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\\n        if (value < 0) {\\n            buf.buf.appendUint8(\\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\\n            );\\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\\n        } else {\\n            writeUInt256(buf, uint256(value));\\n        }\\n    }\\n\\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\\n    }\\n\\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\\n        if(value >= 0) {\\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\\n        } else{\\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\\n        }\\n    }\\n\\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\\n        buf.buf.append(value);\\n    }\\n\\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\\n        buf.buf.append(bytes(value));\\n    }\\n\\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\\n    }\\n\\n    function writeNull(CBORBuffer memory buf) internal pure {\\n        writeContentFree(buf, CBOR_NULL);\\n    }\\n\\n    function writeUndefined(CBORBuffer memory buf) internal pure {\\n        writeContentFree(buf, CBOR_UNDEFINED);\\n    }\\n\\n    function startArray(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n        buf.depth += 1;\\n    }\\n\\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\\n    }\\n\\n    function startMap(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n        buf.depth += 1;\\n    }\\n\\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\\n    }\\n\\n    function endSequence(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n        buf.depth -= 1;\\n    }\\n\\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\\n        writeString(buf, key);\\n        writeString(buf, value);\\n    }\\n\\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\\n        writeString(buf, key);\\n        writeBytes(buf, value);\\n    }\\n\\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\\n        writeString(buf, key);\\n        writeUInt256(buf, value);\\n    }\\n\\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\\n        writeString(buf, key);\\n        writeInt256(buf, value);\\n    }\\n\\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\\n        writeString(buf, key);\\n        writeUInt64(buf, value);\\n    }\\n\\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\\n        writeString(buf, key);\\n        writeInt64(buf, value);\\n    }\\n\\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\\n        writeString(buf, key);\\n        writeBool(buf, value);\\n    }\\n\\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        writeNull(buf);\\n    }\\n\\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        writeUndefined(buf);\\n    }\\n\\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        startMap(buf);\\n    }\\n\\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        startArray(buf);\\n    }\\n\\n    function writeFixedNumeric(\\n        CBORBuffer memory buf,\\n        uint8 major,\\n        uint64 value\\n    ) private pure {\\n        if (value <= 23) {\\n            buf.buf.appendUint8(uint8((major << 5) | value));\\n        } else if (value <= 0xFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 24));\\n            buf.buf.appendInt(value, 1);\\n        } else if (value <= 0xFFFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 25));\\n            buf.buf.appendInt(value, 2);\\n        } else if (value <= 0xFFFFFFFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 26));\\n            buf.buf.appendInt(value, 4);\\n        } else {\\n            buf.buf.appendUint8(uint8((major << 5) | 27));\\n            buf.buf.appendInt(value, 8);\\n        }\\n    }\\n\\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\\n        private\\n        pure\\n    {\\n        buf.buf.appendUint8(uint8((major << 5) | 31));\\n    }\\n\\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\\n        private\\n        pure\\n    {\\n        writeFixedNumeric(buf, major, length);\\n    }\\n\\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\\n    }\\n}\",\"keccak256\":\"0xcbcaeb0176e57857295777a6ffee8842b2cb59b3c0690587e798da89a9e5bb46\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5033600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550612ac9806100616000396000f3fe6080604052600436106100865760003560e01c80638da5cb5b116100595780638da5cb5b146101615780638f8a6d8f1461018c578063b97c601a146101c9578063d4a0cd0a146101f2578063e1fb0bba1461021b57610086565b80631a7fd6c61461008b5780633d7650b2146100c85780634f9c09cc146101055780636aba510b14610121575b600080fd5b34801561009757600080fd5b506100b260048036038101906100ad9190611c94565b610244565b6040516100bf9190611d0b565b60405180910390f35b3480156100d457600080fd5b506100ef60048036038101906100ea9190611d26565b610289565b6040516100fc9190611d0b565b60405180910390f35b61011f600480360381019061011a9190611d6f565b6102bf565b005b34801561012d57600080fd5b5061014860048036038101906101439190611dd2565b6102c2565b6040516101589493929190611f22565b60405180910390f35b34801561016d57600080fd5b506101766103b0565b6040516101839190611faf565b60405180910390f35b34801561019857600080fd5b506101b360048036038101906101ae9190611d26565b6103d6565b6040516101c09190611fd9565b60405180910390f35b3480156101d557600080fd5b506101f060048036038101906101eb9190611ff4565b610404565b005b3480156101fe57600080fd5b50610219600480360381019061021491906120c3565b610579565b005b34801561022757600080fd5b50610242600480360381019061023d9190611d6f565b610636565b005b6002828051602081018201805184825260208301602085012081835280955050505050506020528060005260406000206000915091509054906101000a900460ff1681565b6000818051602081018201805184825260208301602085012081835280955050505050506000915054906101000a900460ff1681565b50565b6000806000606060008073fe0000000000000000000000000000000000000573ffffffffffffffffffffffffffffffffffffffff168c8c8c8c8c8c60405160200161031296959493929190612123565b60405160208183030381529060405260405161032e91906121c7565b600060405180830381855af49150503d8060008114610369576040519150601f19603f3d011682016040523d82523d6000602084013e61036e565b606091505b509150915060008060008380602001905181019061038c919061228f565b92509250925084838383985098509850985050505050509650965096509692505050565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6001818051602081018201805184825260208301602085012081835280955050505050506000915090505481565b60008360405161041491906121c7565b908152602001604051809103902060009054906101000a900460ff1661046f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161046690612381565b60405180910390fd5b8060018460405161048091906121c7565b908152602001604051809103902054146104cf576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104c6906123ed565b60405180910390fd5b6104d983836106d9565b610518576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161050f9061247f565b60405180910390fd5b600160028460405161052a91906121c7565b908152602001604051809103902060008467ffffffffffffffff1667ffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550505050565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146105d357600080fd5b6001600084846040516105e79291906124c4565b908152602001604051809103902060006101000a81548160ff021916908315150217905550806001848460405161061f9291906124c4565b908152602001604051809103902081905550505050565b600061065960405180602001604052808467ffffffffffffffff1681525061073a565b9050600061067e60405180602001604052808567ffffffffffffffff168152506107be565b90506106a182600001518260000151846020015167ffffffffffffffff16610404565b60006106c460405180602001604052808667ffffffffffffffff16815250610842565b90506106d381600001516108c6565b50505050565b6000806002846040516106ec91906121c7565b908152602001604051809103902060008467ffffffffffffffff1667ffffffffffffffff16815260200190815260200160002060009054906101000a900460ff169050801591505092915050565b610742611a62565b600061074d83610904565b90506000610796634505760a6040518060400160405280600281526020017e0500000000000000000000000000000000000000000000000000000000000081525084607161093c565b90506107a0611a62565b6107b3828261096790919063ffffffff16565b809350505050919050565b6107c6611a86565b60006107d1836109e8565b9050600061081a6337bc36da6040518060400160405280600281526020017e0500000000000000000000000000000000000000000000000000000000000081525084607161093c565b9050610824611a86565b6108378282610a2090919063ffffffff16565b809350505050919050565b61084a611aa3565b600061085583610a5b565b9050600061089e6307a1f0516040518060400160405280600281526020017e0500000000000000000000000000000000000000000000000000000000000081525084607161093c565b90506108a8611aa3565b6108bb8282610a9390919063ffffffff16565b809350505050919050565b6000604051806020016040528060008152509050606090506000670de0b6b3a764000090506108fb6000826000808688610ace565b50505050505050565b606060006109126040610bbc565b905061092b836000015182610be390919063ffffffff16565b61093481610bf3565b915050919050565b606061095d61094a86610c4c565b67ffffffffffffffff1685858534610c56565b9050949350505050565b60008061097d8284610cfb90919063ffffffff16565b809350819250505060008111156109e2576109a18284610d4a90919063ffffffff16565b8560000181945082905250506109c08284610ef490919063ffffffff16565b856020018194508267ffffffffffffffff1667ffffffffffffffff1681525050505b50505050565b606060006109f66040610bbc565b9050610a0f836000015182610be390919063ffffffff16565b610a1881610bf3565b915050919050565b6000610a358183610ef490919063ffffffff16565b846000018193508267ffffffffffffffff1667ffffffffffffffff168152505050505050565b60606000610a696040610bbc565b9050610a82836000015182610be390919063ffffffff16565b610a8b81610bf3565b915050919050565b6000610aa88183610ef490919063ffffffff16565b846000018193508267ffffffffffffffff1667ffffffffffffffff168152505050505050565b6000806000606060008073fe0000000000000000000000000000000000000573ffffffffffffffffffffffffffffffffffffffff168c8c8c8c8c8c604051602001610b1e96959493929190612123565b604051602081830303815290604052604051610b3a91906121c7565b600060405180830381855af49150503d8060008114610b75576040519150601f19603f3d011682016040523d82523d6000602084013e610b7a565b606091505b5091509150600080600083806020019051810190610b98919061228f565b92509250925084838383985098509850985050505050509650965096509692505050565b610bc4611ac0565b610bd2816000015183610f43565b506000816020018181525050919050565b610bef82600083610fbc565b5050565b60606000826020015114610c3c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c3390612529565b60405180910390fd5b8160000151600001519050919050565b6000819050919050565b6060600080600080610c75610c6a8b610c4c565b8760008a8c8e611165565b935093509350935060008314610c8a84611253565b604051602001610c9a91906125b6565b60405160208183030381529060405290610cea576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ce19190612615565b60405180910390fd5b508094505050505095945050505050565b600080600080610d0b86866112e1565b8167ffffffffffffffff169150809750819350829450505050600460ff168260ff1614610d3b57610d3a612637565b5b80859350935050509250929050565b60606000806000610d5b86866112e1565b8167ffffffffffffffff169150809750819350829450505050600660ff168260ff161480610d8f5750600260ff168260ff16145b610d9c57610d9b612637565b5b600660ff168260ff1603610de557610db486866112e1565b8167ffffffffffffffff169150809750819350829450505050600260ff168260ff1614610de457610de3612637565b5b5b60008186610df39190612695565b905060008267ffffffffffffffff811115610e1157610e10611b29565b5b6040519080825280601f01601f191660200182016040528015610e435781602001600182028036833780820191505090505b5090506000808890505b83811015610ed657898181518110610e6857610e676126c9565b5b602001015160f81c60f81b838381518110610e8657610e856126c9565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508180610ec0906126f8565b9250508080610ece906126f8565b915050610e4d565b50818489610ee49190612695565b9650965050505050509250929050565b600080600080610f0486866112e1565b8167ffffffffffffffff169150809750819350829450505050600060ff168260ff1614610f3457610f33612637565b5b80859350935050509250929050565b610f4b611ae0565b6000602083610f5a919061276f565b14610f8657602082610f6c919061276f565b6020610f7891906127a0565b82610f839190612695565b91505b818360200181815250506040518084526000815282810160200181811015610fad57600080fd5b80604052505082905092915050565b60178167ffffffffffffffff1611610ff757610ff18160058460ff16901b60ff1617846000015161146f90919063ffffffff16565b50611160565b60ff8167ffffffffffffffff16116110555761102a601860058460ff16901b17846000015161146f90919063ffffffff16565b5061104f8167ffffffffffffffff16600185600001516114d99092919063ffffffff16565b5061115f565b61ffff8167ffffffffffffffff16116110b457611089601960058460ff16901b17846000015161146f90919063ffffffff16565b506110ae8167ffffffffffffffff16600285600001516114d99092919063ffffffff16565b5061115e565b63ffffffff8167ffffffffffffffff1611611115576110ea601a60058460ff16901b17846000015161146f90919063ffffffff16565b5061110f8167ffffffffffffffff16600485600001516114d99092919063ffffffff16565b5061115d565b611136601b60058460ff16901b17846000015161146f90919063ffffffff16565b5061115b8167ffffffffffffffff16600885600001516114d99092919063ffffffff16565b505b5b5b5b505050565b6000806000606060008073fe0000000000000000000000000000000000000373ffffffffffffffffffffffffffffffffffffffff168c8c8c8c8c8c6040516020016111b5969594939291906127d4565b6040516020818303038152906040526040516111d191906121c7565b600060405180830381855af49150503d806000811461120c576040519150601f19603f3d011682016040523d82523d6000602084013e611211565b606091505b509150915060008060008380602001905181019061122f919061228f565b92509250925084838383985098509850985050505050509650965096509692505050565b60606000821261127257604051806020016040528060008152506112a9565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6112ba6112b584611566565b611582565b6040516020016112cb929190612843565b6040516020818303038152906040529050919050565b6000806000806112f18686611650565b90506001856113009190612695565b94506000600560e0831660ff16901c90506000601f83169050601c8160ff161061132d5761132c612637565b5b60188160ff161015611350578181888160ff169150955095509550505050611468565b60188160ff16036113a55760006113678989611650565b90506001886113769190612695565b975060188160ff16101561138d5761138c612637565b5b8281898160ff16915096509650965050505050611468565b60198160ff16036113e65760006113bc89896116b7565b90506002886113cb9190612695565b97508281898161ffff16915096509650965050505050611468565b601a8160ff16036114295760006113fd898961171e565b905060048861140c9190612695565b97508281898163ffffffff16915096509650965050505050611468565b601b8160ff161461143d5761143c612637565b5b60006114498989611785565b90506008886114589190612695565b9750828189965096509650505050505b9250925092565b611477611ae0565b6000836000015151905060006001826114909190612695565b9050846020015182106114b4576114b3856002836114ae9190612867565b6117ec565b5b845160208382010185815381518311156114cc578282525b5050849250505092915050565b6114e1611ae0565b60008460000151519050600081846114f99190612695565b9050856020015181111561151e5761151d866002836115189190612867565b6117ec565b5b600060018561010061153091906129dc565b61153a91906127a0565b905086518281018783198251161781528151841115611557578382525b50508693505050509392505050565b600080821215611579578160000361157b565b815b9050919050565b60606000600161159184611810565b01905060008167ffffffffffffffff8111156115b0576115af611b29565b5b6040519080825280601f01601f1916602001820160405280156115e25781602001600182028036833780820191505090505b509050600082602001820190505b600115611645578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161163957611638612740565b5b049450600085036115f0575b819350505050919050565b600060018261165f9190612695565b835110156116a2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161169990612a73565b60405180910390fd5b60008260010184015190508091505092915050565b60006002826116c69190612695565b83511015611709576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161170090612a73565b60405180910390fd5b60008260020184015190508091505092915050565b600060048261172d9190612695565b83511015611770576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161176790612a73565b60405180910390fd5b60008260040184015190508091505092915050565b60006008826117949190612695565b835110156117d7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117ce90612a73565b60405180910390fd5b60008260080184015190508091505092915050565b6000826000015190506117ff8383610f43565b5061180a8382611963565b50505050565b600080600090507a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000831061186e577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161186457611863612740565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106118ab576d04ee2d6d415b85acef810000000083816118a1576118a0612740565b5b0492506020810190505b662386f26fc1000083106118da57662386f26fc1000083816118d0576118cf612740565b5b0492506010810190505b6305f5e1008310611903576305f5e10083816118f9576118f8612740565b5b0492506008810190505b612710831061192857612710838161191e5761191d612740565b5b0492506004810190505b6064831061194b576064838161194157611940612740565b5b0492506002810190505b600a831061195a576001810190505b80915050919050565b61196b611ae0565b6119778383845161197f565b905092915050565b611987611ae0565b825182111561199557600080fd5b60008460000151519050600083826119ad9190612695565b905085602001518111156119d2576119d1866002836119cc9190612867565b6117ec565b5b600080875180518560208301019350808511156119ed578482525b60208901925050505b60208610611a345780518252602082611a0f9190612695565b9150602081611a1e9190612695565b9050602086611a2d91906127a0565b95506119f6565b60006001876020036101000a0390508019825116818451168181178552505050879450505050509392505050565b604051806040016040528060608152602001600067ffffffffffffffff1681525090565b6040518060200160405280600067ffffffffffffffff1681525090565b6040518060200160405280600067ffffffffffffffff1681525090565b6040518060400160405280611ad3611ae0565b8152602001600081525090565b604051806040016040528060608152602001600081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b611b6182611b18565b810181811067ffffffffffffffff82111715611b8057611b7f611b29565b5b80604052505050565b6000611b93611afa565b9050611b9f8282611b58565b919050565b600067ffffffffffffffff821115611bbf57611bbe611b29565b5b611bc882611b18565b9050602081019050919050565b82818337600083830152505050565b6000611bf7611bf284611ba4565b611b89565b905082815260208101848484011115611c1357611c12611b13565b5b611c1e848285611bd5565b509392505050565b600082601f830112611c3b57611c3a611b0e565b5b8135611c4b848260208601611be4565b91505092915050565b600067ffffffffffffffff82169050919050565b611c7181611c54565b8114611c7c57600080fd5b50565b600081359050611c8e81611c68565b92915050565b60008060408385031215611cab57611caa611b04565b5b600083013567ffffffffffffffff811115611cc957611cc8611b09565b5b611cd585828601611c26565b9250506020611ce685828601611c7f565b9150509250929050565b60008115159050919050565b611d0581611cf0565b82525050565b6000602082019050611d206000830184611cfc565b92915050565b600060208284031215611d3c57611d3b611b04565b5b600082013567ffffffffffffffff811115611d5a57611d59611b09565b5b611d6684828501611c26565b91505092915050565b600060208284031215611d8557611d84611b04565b5b6000611d9384828501611c7f565b91505092915050565b6000819050919050565b611daf81611d9c565b8114611dba57600080fd5b50565b600081359050611dcc81611da6565b92915050565b60008060008060008060c08789031215611def57611dee611b04565b5b6000611dfd89828a01611c7f565b9650506020611e0e89828a01611dbd565b9550506040611e1f89828a01611c7f565b9450506060611e3089828a01611c7f565b935050608087013567ffffffffffffffff811115611e5157611e50611b09565b5b611e5d89828a01611c26565b92505060a0611e6e89828a01611c7f565b9150509295509295509295565b6000819050919050565b611e8e81611e7b565b82525050565b611e9d81611c54565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611edd578082015181840152602081019050611ec2565b60008484015250505050565b6000611ef482611ea3565b611efe8185611eae565b9350611f0e818560208601611ebf565b611f1781611b18565b840191505092915050565b6000608082019050611f376000830187611cfc565b611f446020830186611e85565b611f516040830185611e94565b8181036060830152611f638184611ee9565b905095945050505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611f9982611f6e565b9050919050565b611fa981611f8e565b82525050565b6000602082019050611fc46000830184611fa0565b92915050565b611fd381611d9c565b82525050565b6000602082019050611fee6000830184611fca565b92915050565b60008060006060848603121561200d5761200c611b04565b5b600084013567ffffffffffffffff81111561202b5761202a611b09565b5b61203786828701611c26565b935050602061204886828701611c7f565b925050604061205986828701611dbd565b9150509250925092565b600080fd5b600080fd5b60008083601f84011261208357612082611b0e565b5b8235905067ffffffffffffffff8111156120a05761209f612063565b5b6020830191508360018202830111156120bc576120bb612068565b5b9250929050565b6000806000604084860312156120dc576120db611b04565b5b600084013567ffffffffffffffff8111156120fa576120f9611b09565b5b6121068682870161206d565b9350935050602061211986828701611dbd565b9150509250925092565b600060c0820190506121386000830189611e94565b6121456020830188611fca565b6121526040830187611e94565b61215f6060830186611e94565b81810360808301526121718185611ee9565b905061218060a0830184611e94565b979650505050505050565b600081905092915050565b60006121a182611ea3565b6121ab818561218b565b93506121bb818560208601611ebf565b80840191505092915050565b60006121d38284612196565b915081905092915050565b6121e781611e7b565b81146121f257600080fd5b50565b600081519050612204816121de565b92915050565b60008151905061221981611c68565b92915050565b600061223261222d84611ba4565b611b89565b90508281526020810184848401111561224e5761224d611b13565b5b612259848285611ebf565b509392505050565b600082601f83011261227657612275611b0e565b5b815161228684826020860161221f565b91505092915050565b6000806000606084860312156122a8576122a7611b04565b5b60006122b6868287016121f5565b93505060206122c78682870161220a565b925050604084015167ffffffffffffffff8111156122e8576122e7611b09565b5b6122f486828701612261565b9150509250925092565b600082825260208201905092915050565b7f636964206d757374206265206164646564206265666f726520617574686f726960008201527f7a696e6700000000000000000000000000000000000000000000000000000000602082015250565b600061236b6024836122fe565b91506123768261230f565b604082019050919050565b6000602082019050818103600083015261239a8161235e565b9050919050565b7f646174612073697a65206d757374206d61746368206578706563746564000000600082015250565b60006123d7601d836122fe565b91506123e2826123a1565b602082019050919050565b60006020820190508181036000830152612406816123ca565b9050919050565b7f6465616c206661696c656420706f6c69637920636865636b3a2068617320707260008201527f6f766964657220616c726561647920636c61696d65642074686973206369643f602082015250565b60006124696040836122fe565b91506124748261240d565b604082019050919050565b600060208201905081810360008301526124988161245c565b9050919050565b60006124ab838561218b565b93506124b8838584611bd5565b82840190509392505050565b60006124d182848661249f565b91508190509392505050565b7f496e76616c69642043424f520000000000000000000000000000000000000000600082015250565b6000612513600c836122fe565b915061251e826124dd565b602082019050919050565b6000602082019050818103600083015261254281612506565b9050919050565b7f6163746f72206572726f7220636f646520000000000000000000000000000000815250565b600081519050919050565b600081905092915050565b60006125908261256f565b61259a818561257a565b93506125aa818560208601611ebf565b80840191505092915050565b60006125c182612549565b6011820191506125d18284612585565b915081905092915050565b60006125e78261256f565b6125f181856122fe565b9350612601818560208601611ebf565b61260a81611b18565b840191505092915050565b6000602082019050818103600083015261262f81846125dc565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006126a082611d9c565b91506126ab83611d9c565b92508282019050808211156126c3576126c2612666565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600061270382611d9c565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361273557612734612666565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061277a82611d9c565b915061278583611d9c565b92508261279557612794612740565b5b828206905092915050565b60006127ab82611d9c565b91506127b683611d9c565b92508282039050818111156127ce576127cd612666565b5b92915050565b600060c0820190506127e96000830189611e94565b6127f66020830188611fca565b6128036040830187611e94565b6128106060830186611e94565b81810360808301526128228185611ee9565b905081810360a08301526128368184611ee9565b9050979650505050505050565b600061284f8285612585565b915061285b8284612585565b91508190509392505050565b600061287282611d9c565b915061287d83611d9c565b925082820261288b81611d9c565b915082820484148315176128a2576128a1612666565b5b5092915050565b60008160011c9050919050565b6000808291508390505b6001851115612900578086048111156128dc576128db612666565b5b60018516156128eb5780820291505b80810290506128f9856128a9565b94506128c0565b94509492505050565b60008261291957600190506129d5565b8161292757600090506129d5565b816001811461293d576002811461294757612976565b60019150506129d5565b60ff84111561295957612958612666565b5b8360020a9150848211156129705761296f612666565b5b506129d5565b5060208310610133831016604e8410600b84101617156129ab5782820a9050838111156129a6576129a5612666565b5b6129d5565b6129b884848460016128b6565b925090508184048111156129cf576129ce612666565b5b81810290505b9392505050565b60006129e782611d9c565b91506129f283611d9c565b9250612a1f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484612909565b905092915050565b7f736c6963696e67206f7574206f662072616e6765000000000000000000000000600082015250565b6000612a5d6014836122fe565b9150612a6882612a27565b602082019050919050565b60006020820190508181036000830152612a8c81612a50565b905091905056fea2646970667358221220c1e8589e7029bf5278c2fa1dff2ef266f55ee4e02141451fcc26b0f886e452b364736f6c63430008110033",
  "deployedBytecode": "0x6080604052600436106100865760003560e01c80638da5cb5b116100595780638da5cb5b146101615780638f8a6d8f1461018c578063b97c601a146101c9578063d4a0cd0a146101f2578063e1fb0bba1461021b57610086565b80631a7fd6c61461008b5780633d7650b2146100c85780634f9c09cc146101055780636aba510b14610121575b600080fd5b34801561009757600080fd5b506100b260048036038101906100ad9190611c94565b610244565b6040516100bf9190611d0b565b60405180910390f35b3480156100d457600080fd5b506100ef60048036038101906100ea9190611d26565b610289565b6040516100fc9190611d0b565b60405180910390f35b61011f600480360381019061011a9190611d6f565b6102bf565b005b34801561012d57600080fd5b5061014860048036038101906101439190611dd2565b6102c2565b6040516101589493929190611f22565b60405180910390f35b34801561016d57600080fd5b506101766103b0565b6040516101839190611faf565b60405180910390f35b34801561019857600080fd5b506101b360048036038101906101ae9190611d26565b6103d6565b6040516101c09190611fd9565b60405180910390f35b3480156101d557600080fd5b506101f060048036038101906101eb9190611ff4565b610404565b005b3480156101fe57600080fd5b50610219600480360381019061021491906120c3565b610579565b005b34801561022757600080fd5b50610242600480360381019061023d9190611d6f565b610636565b005b6002828051602081018201805184825260208301602085012081835280955050505050506020528060005260406000206000915091509054906101000a900460ff1681565b6000818051602081018201805184825260208301602085012081835280955050505050506000915054906101000a900460ff1681565b50565b6000806000606060008073fe0000000000000000000000000000000000000573ffffffffffffffffffffffffffffffffffffffff168c8c8c8c8c8c60405160200161031296959493929190612123565b60405160208183030381529060405260405161032e91906121c7565b600060405180830381855af49150503d8060008114610369576040519150601f19603f3d011682016040523d82523d6000602084013e61036e565b606091505b509150915060008060008380602001905181019061038c919061228f565b92509250925084838383985098509850985050505050509650965096509692505050565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6001818051602081018201805184825260208301602085012081835280955050505050506000915090505481565b60008360405161041491906121c7565b908152602001604051809103902060009054906101000a900460ff1661046f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161046690612381565b60405180910390fd5b8060018460405161048091906121c7565b908152602001604051809103902054146104cf576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104c6906123ed565b60405180910390fd5b6104d983836106d9565b610518576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161050f9061247f565b60405180910390fd5b600160028460405161052a91906121c7565b908152602001604051809103902060008467ffffffffffffffff1667ffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550505050565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146105d357600080fd5b6001600084846040516105e79291906124c4565b908152602001604051809103902060006101000a81548160ff021916908315150217905550806001848460405161061f9291906124c4565b908152602001604051809103902081905550505050565b600061065960405180602001604052808467ffffffffffffffff1681525061073a565b9050600061067e60405180602001604052808567ffffffffffffffff168152506107be565b90506106a182600001518260000151846020015167ffffffffffffffff16610404565b60006106c460405180602001604052808667ffffffffffffffff16815250610842565b90506106d381600001516108c6565b50505050565b6000806002846040516106ec91906121c7565b908152602001604051809103902060008467ffffffffffffffff1667ffffffffffffffff16815260200190815260200160002060009054906101000a900460ff169050801591505092915050565b610742611a62565b600061074d83610904565b90506000610796634505760a6040518060400160405280600281526020017e0500000000000000000000000000000000000000000000000000000000000081525084607161093c565b90506107a0611a62565b6107b3828261096790919063ffffffff16565b809350505050919050565b6107c6611a86565b60006107d1836109e8565b9050600061081a6337bc36da6040518060400160405280600281526020017e0500000000000000000000000000000000000000000000000000000000000081525084607161093c565b9050610824611a86565b6108378282610a2090919063ffffffff16565b809350505050919050565b61084a611aa3565b600061085583610a5b565b9050600061089e6307a1f0516040518060400160405280600281526020017e0500000000000000000000000000000000000000000000000000000000000081525084607161093c565b90506108a8611aa3565b6108bb8282610a9390919063ffffffff16565b809350505050919050565b6000604051806020016040528060008152509050606090506000670de0b6b3a764000090506108fb6000826000808688610ace565b50505050505050565b606060006109126040610bbc565b905061092b836000015182610be390919063ffffffff16565b61093481610bf3565b915050919050565b606061095d61094a86610c4c565b67ffffffffffffffff1685858534610c56565b9050949350505050565b60008061097d8284610cfb90919063ffffffff16565b809350819250505060008111156109e2576109a18284610d4a90919063ffffffff16565b8560000181945082905250506109c08284610ef490919063ffffffff16565b856020018194508267ffffffffffffffff1667ffffffffffffffff1681525050505b50505050565b606060006109f66040610bbc565b9050610a0f836000015182610be390919063ffffffff16565b610a1881610bf3565b915050919050565b6000610a358183610ef490919063ffffffff16565b846000018193508267ffffffffffffffff1667ffffffffffffffff168152505050505050565b60606000610a696040610bbc565b9050610a82836000015182610be390919063ffffffff16565b610a8b81610bf3565b915050919050565b6000610aa88183610ef490919063ffffffff16565b846000018193508267ffffffffffffffff1667ffffffffffffffff168152505050505050565b6000806000606060008073fe0000000000000000000000000000000000000573ffffffffffffffffffffffffffffffffffffffff168c8c8c8c8c8c604051602001610b1e96959493929190612123565b604051602081830303815290604052604051610b3a91906121c7565b600060405180830381855af49150503d8060008114610b75576040519150601f19603f3d011682016040523d82523d6000602084013e610b7a565b606091505b5091509150600080600083806020019051810190610b98919061228f565b92509250925084838383985098509850985050505050509650965096509692505050565b610bc4611ac0565b610bd2816000015183610f43565b506000816020018181525050919050565b610bef82600083610fbc565b5050565b60606000826020015114610c3c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c3390612529565b60405180910390fd5b8160000151600001519050919050565b6000819050919050565b6060600080600080610c75610c6a8b610c4c565b8760008a8c8e611165565b935093509350935060008314610c8a84611253565b604051602001610c9a91906125b6565b60405160208183030381529060405290610cea576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ce19190612615565b60405180910390fd5b508094505050505095945050505050565b600080600080610d0b86866112e1565b8167ffffffffffffffff169150809750819350829450505050600460ff168260ff1614610d3b57610d3a612637565b5b80859350935050509250929050565b60606000806000610d5b86866112e1565b8167ffffffffffffffff169150809750819350829450505050600660ff168260ff161480610d8f5750600260ff168260ff16145b610d9c57610d9b612637565b5b600660ff168260ff1603610de557610db486866112e1565b8167ffffffffffffffff169150809750819350829450505050600260ff168260ff1614610de457610de3612637565b5b5b60008186610df39190612695565b905060008267ffffffffffffffff811115610e1157610e10611b29565b5b6040519080825280601f01601f191660200182016040528015610e435781602001600182028036833780820191505090505b5090506000808890505b83811015610ed657898181518110610e6857610e676126c9565b5b602001015160f81c60f81b838381518110610e8657610e856126c9565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508180610ec0906126f8565b9250508080610ece906126f8565b915050610e4d565b50818489610ee49190612695565b9650965050505050509250929050565b600080600080610f0486866112e1565b8167ffffffffffffffff169150809750819350829450505050600060ff168260ff1614610f3457610f33612637565b5b80859350935050509250929050565b610f4b611ae0565b6000602083610f5a919061276f565b14610f8657602082610f6c919061276f565b6020610f7891906127a0565b82610f839190612695565b91505b818360200181815250506040518084526000815282810160200181811015610fad57600080fd5b80604052505082905092915050565b60178167ffffffffffffffff1611610ff757610ff18160058460ff16901b60ff1617846000015161146f90919063ffffffff16565b50611160565b60ff8167ffffffffffffffff16116110555761102a601860058460ff16901b17846000015161146f90919063ffffffff16565b5061104f8167ffffffffffffffff16600185600001516114d99092919063ffffffff16565b5061115f565b61ffff8167ffffffffffffffff16116110b457611089601960058460ff16901b17846000015161146f90919063ffffffff16565b506110ae8167ffffffffffffffff16600285600001516114d99092919063ffffffff16565b5061115e565b63ffffffff8167ffffffffffffffff1611611115576110ea601a60058460ff16901b17846000015161146f90919063ffffffff16565b5061110f8167ffffffffffffffff16600485600001516114d99092919063ffffffff16565b5061115d565b611136601b60058460ff16901b17846000015161146f90919063ffffffff16565b5061115b8167ffffffffffffffff16600885600001516114d99092919063ffffffff16565b505b5b5b5b505050565b6000806000606060008073fe0000000000000000000000000000000000000373ffffffffffffffffffffffffffffffffffffffff168c8c8c8c8c8c6040516020016111b5969594939291906127d4565b6040516020818303038152906040526040516111d191906121c7565b600060405180830381855af49150503d806000811461120c576040519150601f19603f3d011682016040523d82523d6000602084013e611211565b606091505b509150915060008060008380602001905181019061122f919061228f565b92509250925084838383985098509850985050505050509650965096509692505050565b60606000821261127257604051806020016040528060008152506112a9565b6040518060400160405280600181526020017f2d000000000000000000000000000000000000000000000000000000000000008152505b6112ba6112b584611566565b611582565b6040516020016112cb929190612843565b6040516020818303038152906040529050919050565b6000806000806112f18686611650565b90506001856113009190612695565b94506000600560e0831660ff16901c90506000601f83169050601c8160ff161061132d5761132c612637565b5b60188160ff161015611350578181888160ff169150955095509550505050611468565b60188160ff16036113a55760006113678989611650565b90506001886113769190612695565b975060188160ff16101561138d5761138c612637565b5b8281898160ff16915096509650965050505050611468565b60198160ff16036113e65760006113bc89896116b7565b90506002886113cb9190612695565b97508281898161ffff16915096509650965050505050611468565b601a8160ff16036114295760006113fd898961171e565b905060048861140c9190612695565b97508281898163ffffffff16915096509650965050505050611468565b601b8160ff161461143d5761143c612637565b5b60006114498989611785565b90506008886114589190612695565b9750828189965096509650505050505b9250925092565b611477611ae0565b6000836000015151905060006001826114909190612695565b9050846020015182106114b4576114b3856002836114ae9190612867565b6117ec565b5b845160208382010185815381518311156114cc578282525b5050849250505092915050565b6114e1611ae0565b60008460000151519050600081846114f99190612695565b9050856020015181111561151e5761151d866002836115189190612867565b6117ec565b5b600060018561010061153091906129dc565b61153a91906127a0565b905086518281018783198251161781528151841115611557578382525b50508693505050509392505050565b600080821215611579578160000361157b565b815b9050919050565b60606000600161159184611810565b01905060008167ffffffffffffffff8111156115b0576115af611b29565b5b6040519080825280601f01601f1916602001820160405280156115e25781602001600182028036833780820191505090505b509050600082602001820190505b600115611645578080600190039150507f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a858161163957611638612740565b5b049450600085036115f0575b819350505050919050565b600060018261165f9190612695565b835110156116a2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161169990612a73565b60405180910390fd5b60008260010184015190508091505092915050565b60006002826116c69190612695565b83511015611709576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161170090612a73565b60405180910390fd5b60008260020184015190508091505092915050565b600060048261172d9190612695565b83511015611770576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161176790612a73565b60405180910390fd5b60008260040184015190508091505092915050565b60006008826117949190612695565b835110156117d7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117ce90612a73565b60405180910390fd5b60008260080184015190508091505092915050565b6000826000015190506117ff8383610f43565b5061180a8382611963565b50505050565b600080600090507a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000831061186e577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000838161186457611863612740565b5b0492506040810190505b6d04ee2d6d415b85acef810000000083106118ab576d04ee2d6d415b85acef810000000083816118a1576118a0612740565b5b0492506020810190505b662386f26fc1000083106118da57662386f26fc1000083816118d0576118cf612740565b5b0492506010810190505b6305f5e1008310611903576305f5e10083816118f9576118f8612740565b5b0492506008810190505b612710831061192857612710838161191e5761191d612740565b5b0492506004810190505b6064831061194b576064838161194157611940612740565b5b0492506002810190505b600a831061195a576001810190505b80915050919050565b61196b611ae0565b6119778383845161197f565b905092915050565b611987611ae0565b825182111561199557600080fd5b60008460000151519050600083826119ad9190612695565b905085602001518111156119d2576119d1866002836119cc9190612867565b6117ec565b5b600080875180518560208301019350808511156119ed578482525b60208901925050505b60208610611a345780518252602082611a0f9190612695565b9150602081611a1e9190612695565b9050602086611a2d91906127a0565b95506119f6565b60006001876020036101000a0390508019825116818451168181178552505050879450505050509392505050565b604051806040016040528060608152602001600067ffffffffffffffff1681525090565b6040518060200160405280600067ffffffffffffffff1681525090565b6040518060200160405280600067ffffffffffffffff1681525090565b6040518060400160405280611ad3611ae0565b8152602001600081525090565b604051806040016040528060608152602001600081525090565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b611b6182611b18565b810181811067ffffffffffffffff82111715611b8057611b7f611b29565b5b80604052505050565b6000611b93611afa565b9050611b9f8282611b58565b919050565b600067ffffffffffffffff821115611bbf57611bbe611b29565b5b611bc882611b18565b9050602081019050919050565b82818337600083830152505050565b6000611bf7611bf284611ba4565b611b89565b905082815260208101848484011115611c1357611c12611b13565b5b611c1e848285611bd5565b509392505050565b600082601f830112611c3b57611c3a611b0e565b5b8135611c4b848260208601611be4565b91505092915050565b600067ffffffffffffffff82169050919050565b611c7181611c54565b8114611c7c57600080fd5b50565b600081359050611c8e81611c68565b92915050565b60008060408385031215611cab57611caa611b04565b5b600083013567ffffffffffffffff811115611cc957611cc8611b09565b5b611cd585828601611c26565b9250506020611ce685828601611c7f565b9150509250929050565b60008115159050919050565b611d0581611cf0565b82525050565b6000602082019050611d206000830184611cfc565b92915050565b600060208284031215611d3c57611d3b611b04565b5b600082013567ffffffffffffffff811115611d5a57611d59611b09565b5b611d6684828501611c26565b91505092915050565b600060208284031215611d8557611d84611b04565b5b6000611d9384828501611c7f565b91505092915050565b6000819050919050565b611daf81611d9c565b8114611dba57600080fd5b50565b600081359050611dcc81611da6565b92915050565b60008060008060008060c08789031215611def57611dee611b04565b5b6000611dfd89828a01611c7f565b9650506020611e0e89828a01611dbd565b9550506040611e1f89828a01611c7f565b9450506060611e3089828a01611c7f565b935050608087013567ffffffffffffffff811115611e5157611e50611b09565b5b611e5d89828a01611c26565b92505060a0611e6e89828a01611c7f565b9150509295509295509295565b6000819050919050565b611e8e81611e7b565b82525050565b611e9d81611c54565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015611edd578082015181840152602081019050611ec2565b60008484015250505050565b6000611ef482611ea3565b611efe8185611eae565b9350611f0e818560208601611ebf565b611f1781611b18565b840191505092915050565b6000608082019050611f376000830187611cfc565b611f446020830186611e85565b611f516040830185611e94565b8181036060830152611f638184611ee9565b905095945050505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000611f9982611f6e565b9050919050565b611fa981611f8e565b82525050565b6000602082019050611fc46000830184611fa0565b92915050565b611fd381611d9c565b82525050565b6000602082019050611fee6000830184611fca565b92915050565b60008060006060848603121561200d5761200c611b04565b5b600084013567ffffffffffffffff81111561202b5761202a611b09565b5b61203786828701611c26565b935050602061204886828701611c7f565b925050604061205986828701611dbd565b9150509250925092565b600080fd5b600080fd5b60008083601f84011261208357612082611b0e565b5b8235905067ffffffffffffffff8111156120a05761209f612063565b5b6020830191508360018202830111156120bc576120bb612068565b5b9250929050565b6000806000604084860312156120dc576120db611b04565b5b600084013567ffffffffffffffff8111156120fa576120f9611b09565b5b6121068682870161206d565b9350935050602061211986828701611dbd565b9150509250925092565b600060c0820190506121386000830189611e94565b6121456020830188611fca565b6121526040830187611e94565b61215f6060830186611e94565b81810360808301526121718185611ee9565b905061218060a0830184611e94565b979650505050505050565b600081905092915050565b60006121a182611ea3565b6121ab818561218b565b93506121bb818560208601611ebf565b80840191505092915050565b60006121d38284612196565b915081905092915050565b6121e781611e7b565b81146121f257600080fd5b50565b600081519050612204816121de565b92915050565b60008151905061221981611c68565b92915050565b600061223261222d84611ba4565b611b89565b90508281526020810184848401111561224e5761224d611b13565b5b612259848285611ebf565b509392505050565b600082601f83011261227657612275611b0e565b5b815161228684826020860161221f565b91505092915050565b6000806000606084860312156122a8576122a7611b04565b5b60006122b6868287016121f5565b93505060206122c78682870161220a565b925050604084015167ffffffffffffffff8111156122e8576122e7611b09565b5b6122f486828701612261565b9150509250925092565b600082825260208201905092915050565b7f636964206d757374206265206164646564206265666f726520617574686f726960008201527f7a696e6700000000000000000000000000000000000000000000000000000000602082015250565b600061236b6024836122fe565b91506123768261230f565b604082019050919050565b6000602082019050818103600083015261239a8161235e565b9050919050565b7f646174612073697a65206d757374206d61746368206578706563746564000000600082015250565b60006123d7601d836122fe565b91506123e2826123a1565b602082019050919050565b60006020820190508181036000830152612406816123ca565b9050919050565b7f6465616c206661696c656420706f6c69637920636865636b3a2068617320707260008201527f6f766964657220616c726561647920636c61696d65642074686973206369643f602082015250565b60006124696040836122fe565b91506124748261240d565b604082019050919050565b600060208201905081810360008301526124988161245c565b9050919050565b60006124ab838561218b565b93506124b8838584611bd5565b82840190509392505050565b60006124d182848661249f565b91508190509392505050565b7f496e76616c69642043424f520000000000000000000000000000000000000000600082015250565b6000612513600c836122fe565b915061251e826124dd565b602082019050919050565b6000602082019050818103600083015261254281612506565b9050919050565b7f6163746f72206572726f7220636f646520000000000000000000000000000000815250565b600081519050919050565b600081905092915050565b60006125908261256f565b61259a818561257a565b93506125aa818560208601611ebf565b80840191505092915050565b60006125c182612549565b6011820191506125d18284612585565b915081905092915050565b60006125e78261256f565b6125f181856122fe565b9350612601818560208601611ebf565b61260a81611b18565b840191505092915050565b6000602082019050818103600083015261262f81846125dc565b905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006126a082611d9c565b91506126ab83611d9c565b92508282019050808211156126c3576126c2612666565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600061270382611d9c565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361273557612734612666565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600061277a82611d9c565b915061278583611d9c565b92508261279557612794612740565b5b828206905092915050565b60006127ab82611d9c565b91506127b683611d9c565b92508282039050818111156127ce576127cd612666565b5b92915050565b600060c0820190506127e96000830189611e94565b6127f66020830188611fca565b6128036040830187611e94565b6128106060830186611e94565b81810360808301526128228185611ee9565b905081810360a08301526128368184611ee9565b9050979650505050505050565b600061284f8285612585565b915061285b8284612585565b91508190509392505050565b600061287282611d9c565b915061287d83611d9c565b925082820261288b81611d9c565b915082820484148315176128a2576128a1612666565b5b5092915050565b60008160011c9050919050565b6000808291508390505b6001851115612900578086048111156128dc576128db612666565b5b60018516156128eb5780820291505b80810290506128f9856128a9565b94506128c0565b94509492505050565b60008261291957600190506129d5565b8161292757600090506129d5565b816001811461293d576002811461294757612976565b60019150506129d5565b60ff84111561295957612958612666565b5b8360020a9150848211156129705761296f612666565b5b506129d5565b5060208310610133831016604e8410600b84101617156129ab5782820a9050838111156129a6576129a5612666565b5b6129d5565b6129b884848460016128b6565b925090508184048111156129cf576129ce612666565b5b81810290505b9392505050565b60006129e782611d9c565b91506129f283611d9c565b9250612a1f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484612909565b905092915050565b7f736c6963696e67206f7574206f662072616e6765000000000000000000000000600082015250565b6000612a5d6014836122fe565b9150612a6882612a27565b602082019050919050565b60006020820190508181036000830152612a8c81612a50565b905091905056fea2646970667358221220c1e8589e7029bf5278c2fa1dff2ef266f55ee4e02141451fcc26b0f886e452b364736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 5578,
        "contract": "contracts/filecoin-api-examples/DealRewarder.sol:DealRewarder",
        "label": "cidSet",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_bytes_memory_ptr,t_bool)"
      },
      {
        "astId": 5582,
        "contract": "contracts/filecoin-api-examples/DealRewarder.sol:DealRewarder",
        "label": "cidSizes",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes_memory_ptr,t_uint256)"
      },
      {
        "astId": 5588,
        "contract": "contracts/filecoin-api-examples/DealRewarder.sol:DealRewarder",
        "label": "cidProviders",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes_memory_ptr,t_mapping(t_uint64,t_bool))"
      },
      {
        "astId": 5590,
        "contract": "contracts/filecoin-api-examples/DealRewarder.sol:DealRewarder",
        "label": "owner",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes_memory_ptr": {
        "encoding": "bytes",
        "label": "bytes",
        "numberOfBytes": "32"
      },
      "t_mapping(t_bytes_memory_ptr,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes_memory_ptr",
        "label": "mapping(bytes => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes_memory_ptr,t_mapping(t_uint64,t_bool))": {
        "encoding": "mapping",
        "key": "t_bytes_memory_ptr",
        "label": "mapping(bytes => mapping(uint64 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint64,t_bool)"
      },
      "t_mapping(t_bytes_memory_ptr,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes_memory_ptr",
        "label": "mapping(bytes => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint64,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint64",
        "label": "mapping(uint64 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}